<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Reference - DDS documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Reference";
    var mkdocs_page_input_path = "dds-reference.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> DDS documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Reference</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#dds.__init__">dds.__init__</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dds.__init__.eval">eval()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dds.__init__.keep">keep()</a>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../test_sklearn/">Tutorial - scikit-learn</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../plotting/">Tutorial - plotting</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">DDS documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Reference</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="dds-package-documentation">DDS package documentation</h1>
<p>This is the reference documentation of all the public-facing functions.</p>
<div class="doc doc-object doc-module">
<h2 class="hidden-toc" href="#dds.__init__" id="dds.__init__" style="visibility: hidden; position: absolute;">
        </h2>
<div class="doc doc-contents first">
<div class="doc doc-children">
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="dds.__init__.eval">

        <code class="highlight language-python">
eval<span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dds_export_graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dds_extra_debug</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dds_stages</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>        </code>


      </h2>
<div class="doc doc-contents ">
<p>Evaluates a function. The result of the function is not stored in the data store, but the function itself may
contain multiple calls to keep().</p>
<p>This function is useful to consider in one evaluation multiple functions that may themselves call keep() or
refer to each other. eval() allows keep() calls to refer to complex arguments that cannot be evaluated before
runtime. eval() als ensures some basic rules such as no circular references, and will eventually
enable automatic parallel execution of internal statements.</p>
<p>See also the documentation of keep() for an example of eval().</p>
<p>:param dds_export_graph: if specified, a file with the dependency graph of the function will be exported.
 NOTE: this requires the pydot or pydotplus package to be installed, as well as the graphviz program.
 These packages must be installed separately. If they are not present, a runtime error will be triggered.</p>
<p>:param dds_extra_debug: (default false). If true, will compute extra statistics to assist with debugging.
  As implemented, it reaches to the store to check which blobs need to be computed.</p>
<p>Simple example.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f1_internal(): return 1</p>
<p>def f1(): return dds.keep("/f1_value", f1_internal)</p>
<p>def f2(): return 2 + f1()</p>
<p>def all_fs():
    f1()
    dds.keep("/f2_value", f2)
In this example, the function is evaluated only once and its result is served to f1 and f2.</p>
</blockquote>
</blockquote>
</blockquote>
<p>:param fun: a function. See eval() for restrictions.
:param args: arguments. See eval() for restrictions.
:param kwargs: (keyworded arguments are currently unsupported)
:return: the return value of the function.</p>
<details class="quote">
          <summary>Source code in <code>dds/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
    <span class="n">fun</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">_Out</span><span class="p">],</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="n">dds_export_graph</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dds_extra_debug</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dds_stages</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ProcessingStage</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_Out</span><span class="p">]:</span>
    <span class="sd">"""</span>
<span class="sd">    Evaluates a function. The result of the function is not stored in the data store, but the function itself may</span>
<span class="sd">    contain multiple calls to keep().</span>

<span class="sd">    This function is useful to consider in one evaluation multiple functions that may themselves call keep() or</span>
<span class="sd">    refer to each other. eval() allows keep() calls to refer to complex arguments that cannot be evaluated before</span>
<span class="sd">    runtime. eval() als ensures some basic rules such as no circular references, and will eventually</span>
<span class="sd">    enable automatic parallel execution of internal statements.</span>

<span class="sd">    See also the documentation of keep() for an example of eval().</span>

<span class="sd">    :param dds_export_graph: if specified, a file with the dependency graph of the function will be exported.</span>
<span class="sd">     NOTE: this requires the pydot or pydotplus package to be installed, as well as the graphviz program.</span>
<span class="sd">     These packages must be installed separately. If they are not present, a runtime error will be triggered.</span>

<span class="sd">    :param dds_extra_debug: (default false). If true, will compute extra statistics to assist with debugging.</span>
<span class="sd">      As implemented, it reaches to the store to check which blobs need to be computed.</span>


<span class="sd">    Simple example.</span>

<span class="sd">    &gt;&gt;&gt; def f1_internal(): return 1</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def f1(): return dds.keep("/f1_value", f1_internal)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def f2(): return 2 + f1()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def all_fs():</span>
<span class="sd">    &gt;&gt;&gt;     f1()</span>
<span class="sd">    &gt;&gt;&gt;     dds.keep("/f2_value", f2)</span>
<span class="sd">    In this example, the function is evaluated only once and its result is served to f1 and f2.</span>

<span class="sd">    :param fun: a function. See eval() for restrictions.</span>
<span class="sd">    :param args: arguments. See eval() for restrictions.</span>
<span class="sd">    :param kwargs: (keyworded arguments are currently unsupported)</span>
<span class="sd">    :return: the return value of the function.</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">_eval</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">dds_export_graph</span><span class="p">,</span> <span class="n">dds_extra_debug</span><span class="p">,</span> <span class="n">dds_stages</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="dds.__init__.keep">

        <code class="highlight language-python">
keep<span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>        </code>


      </h2>
<div class="doc doc-contents ">
<p>Stores the result of calling a function to a specific path. If this particular evaluation has not happened before,
the function will be evaluated again (with the given arguments).</p>
<p>For example, instead of writing:</p>
<pre><code class="language-py">data = my_function(arg1, arg2)
</code></pre>
<p>you should use:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = dds.keep(path, my_function, arg1, arg2)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="accepted-functions">Accepted functions.</h1>
<p>In general, the functions that should be provided are total, non-recursive, deterministic and referentially
 transparent.</p>
<p>Functions have currently the following restrictions:
- no static method, class method
- not recursive
- no generators
- the functions must be in a whitelisted module to be considered, see the whitelist_module() function</p>
<p>They must return storable objects. The exact list depends on the store that is currently deployed.</p>
<h2 id="accepted-arguments">Accepted arguments.</h2>
<p>Only the following classes of arguments are accepted:
- the basic types of python (int, str, bool, float)
- lists and tuples of accepted arguments
- dictionaries. They are evaluated as sorted lists (by their keys)</p>
<h2 id="using-complex-arguments">Using complex arguments</h2>
<p>If more complex arguments should be accepted, two strategies are possible:
- embed them inside the function call
- wrap them inside a function which is then called through eval()</p>
<p>Example: the following code will fail:</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pd.DataFrame({"x":[1]})</p>
<p>def my_stats(data: pd.DataFrame) -&gt; int: return len(data)</p>
<p>stats = dds.keep("/stats", my_stats, data)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The workaround is to use a wrapper function that create the dataframe:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def my_pipeline():
    df = pd.DataFrame({"x":[1]})
    return dds.keep("/stats", my_stats, df) # This will work</p>
<p>stats = dds.eval(my_pipeline)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Another possibility is to move keep the result of the pipeline instead:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def my_pipeline2():
    df = pd.DataFrame({"x":[1]})
    return my_stats(df)</p>
<p>stats = dds.keep("/stats", my_pipeline2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The difference is that my_pipeline will be evaluated at each call (but not my_stats), while my_pipeline2 will
only be evaluated once.</p>
<p>:param path: a path in the storage system which will store the content of the function, evaluated to the given
arguments. It is expected to be in absolute form (starting with "/" if a string
or being an absolute path if a pathlib's Path object).
If this path exists, it will be overwritten silently.</p>
<p>:param fun: A function to evaluate. See text above on the limitations over this function
:param args: the arguments of this function
:param kwargs: (keyworded arguments are currently unsupported)
:return: the value that the function would produce for these arguments</p>
<details class="quote">
          <summary>Source code in <code>dds/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">keep</span><span class="p">(</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DDSPath</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">],</span>
    <span class="n">fun</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">_Out</span><span class="p">],</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Out</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Stores the result of calling a function to a specific path. If this particular evaluation has not happened before,</span>
<span class="sd">    the function will be evaluated again (with the given arguments).</span>

<span class="sd">    For example, instead of writing:</span>

<span class="sd">    ```py</span>
<span class="sd">    data = my_function(arg1, arg2)</span>
<span class="sd">    ```</span>

<span class="sd">    you should use:</span>

<span class="sd">    &gt;&gt;&gt; data = dds.keep(path, my_function, arg1, arg2)</span>

<span class="sd">    Accepted functions.</span>
<span class="sd">    ===================</span>

<span class="sd">    In general, the functions that should be provided are total, non-recursive, deterministic and referentially</span>
<span class="sd">     transparent.</span>

<span class="sd">    Functions have currently the following restrictions:</span>
<span class="sd">    - no static method, class method</span>
<span class="sd">    - not recursive</span>
<span class="sd">    - no generators</span>
<span class="sd">    - the functions must be in a whitelisted module to be considered, see the whitelist_module() function</span>

<span class="sd">    They must return storable objects. The exact list depends on the store that is currently deployed.</span>

<span class="sd">    Accepted arguments.</span>
<span class="sd">    -------------------</span>

<span class="sd">    Only the following classes of arguments are accepted:</span>
<span class="sd">    - the basic types of python (int, str, bool, float)</span>
<span class="sd">    - lists and tuples of accepted arguments</span>
<span class="sd">    - dictionaries. They are evaluated as sorted lists (by their keys)</span>

<span class="sd">    Using complex arguments</span>
<span class="sd">    -----------------------</span>

<span class="sd">    If more complex arguments should be accepted, two strategies are possible:</span>
<span class="sd">    - embed them inside the function call</span>
<span class="sd">    - wrap them inside a function which is then called through eval()</span>

<span class="sd">    Example: the following code will fail:</span>

<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame({"x":[1]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def my_stats(data: pd.DataFrame) -&gt; int: return len(data)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; stats = dds.keep("/stats", my_stats, data)</span>

<span class="sd">    The workaround is to use a wrapper function that create the dataframe:</span>

<span class="sd">    &gt;&gt;&gt; def my_pipeline():</span>
<span class="sd">    &gt;&gt;&gt;     df = pd.DataFrame({"x":[1]})</span>
<span class="sd">    &gt;&gt;&gt;     return dds.keep("/stats", my_stats, df) # This will work</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; stats = dds.eval(my_pipeline)</span>

<span class="sd">    Another possibility is to move keep the result of the pipeline instead:</span>

<span class="sd">    &gt;&gt;&gt; def my_pipeline2():</span>
<span class="sd">    &gt;&gt;&gt;     df = pd.DataFrame({"x":[1]})</span>
<span class="sd">    &gt;&gt;&gt;     return my_stats(df)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; stats = dds.keep("/stats", my_pipeline2)</span>

<span class="sd">    The difference is that my_pipeline will be evaluated at each call (but not my_stats), while my_pipeline2 will</span>
<span class="sd">    only be evaluated once.</span>

<span class="sd">    :param path: a path in the storage system which will store the content of the function, evaluated to the given</span>
<span class="sd">    arguments. It is expected to be in absolute form (starting with "/" if a string</span>
<span class="sd">    or being an absolute path if a pathlib's Path object).</span>
<span class="sd">    If this path exists, it will be overwritten silently.</span>

<span class="sd">    :param fun: A function to evaluate. See text above on the limitations over this function</span>
<span class="sd">    :param args: the arguments of this function</span>
<span class="sd">    :param kwargs: (keyworded arguments are currently unsupported)</span>
<span class="sd">    :return: the value that the function would produce for these arguments</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">_keep</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="dds.__init__.set_store">

        <code class="highlight language-python">
set_store<span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">internal_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dbutils</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">commit_type</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>        </code>


      </h2>
<div class="doc doc-contents ">
<p>Sets a new store.</p>
<p>By default, a local store pointing to /tmp/ is created.
TODO: change this to the user directory.</p>
<p>:param store: a type of store. Currently 'local' (local hard drive) or 'dbfs' (databricks environment) are supported
:param internal_dir: a path in a filesystem for the internal storage. The internal storage contains evaluated blobs
and corresponding metadata.
    - for local: a path in the local filesystem
    - for dbfs: a path in DBFS
:param data_dir: a path in a filesystem for the data storage. All paths provided by the user are guaranteed to map
to a path in the given data storage.
    - for local: a path in the local filesystem. It contains symbolic links to the internal storage
    - for dbfs: a path in DBFS. Objects are copied from the internal storage to the data storage
:param dbutils: (required only for the 'dbfs' store) the dbutils object that is in a notebook
:param commit_type: (DBFS only, 'none', 'links_only', 'full', default 'full'). The type of commit that will be
    executed to update the paths. Committing a path in DBFS involves a full copy, which may be expensive,
    especially if the underlying table uses Databricks Delta. This is why the following options can be used:
    - none: no file will be committed
    - links_only: a metadata link reference to the blob will be updated. This is much faster because it involves
        a 1kb file transfer as opposed to a full copy. This means though that the result will not be readable
        outside of a DDS store, because the file is not fully materialized.</p>
<p>:return: nothing</p>
<details class="quote">
          <summary>Source code in <code>dds/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">set_store</span><span class="p">(</span>
    <span class="n">store</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Store</span><span class="p">],</span>
    <span class="n">internal_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dbutils</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">commit_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Sets a new store.</span>

<span class="sd">    By default, a local store pointing to /tmp/ is created.</span>
<span class="sd">    TODO: change this to the user directory.</span>

<span class="sd">    :param store: a type of store. Currently 'local' (local hard drive) or 'dbfs' (databricks environment) are supported</span>
<span class="sd">    :param internal_dir: a path in a filesystem for the internal storage. The internal storage contains evaluated blobs</span>
<span class="sd">    and corresponding metadata.</span>
<span class="sd">        - for local: a path in the local filesystem</span>
<span class="sd">        - for dbfs: a path in DBFS</span>
<span class="sd">    :param data_dir: a path in a filesystem for the data storage. All paths provided by the user are guaranteed to map</span>
<span class="sd">    to a path in the given data storage.</span>
<span class="sd">        - for local: a path in the local filesystem. It contains symbolic links to the internal storage</span>
<span class="sd">        - for dbfs: a path in DBFS. Objects are copied from the internal storage to the data storage</span>
<span class="sd">    :param dbutils: (required only for the 'dbfs' store) the dbutils object that is in a notebook</span>
<span class="sd">    :param commit_type: (DBFS only, 'none', 'links_only', 'full', default 'full'). The type of commit that will be</span>
<span class="sd">        executed to update the paths. Committing a path in DBFS involves a full copy, which may be expensive,</span>
<span class="sd">        especially if the underlying table uses Databricks Delta. This is why the following options can be used:</span>
<span class="sd">        - none: no file will be committed</span>
<span class="sd">        - links_only: a metadata link reference to the blob will be updated. This is much faster because it involves</span>
<span class="sd">            a 1kb file transfer as opposed to a full copy. This means though that the result will not be readable</span>
<span class="sd">            outside of a DDS store, because the file is not fully materialized.</span>

<span class="sd">    :return: nothing</span>
<span class="sd">    """</span>
    <span class="n">_set_store</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">internal_dir</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">dbutils</span><span class="p">,</span> <span class="n">commit_type</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="dds.__init__.whitelist_module">

        <code class="highlight language-python">
whitelist_module<span class="p">(</span><span class="n">module</span><span class="p">)</span>        </code>


      </h2>
<div class="doc doc-contents ">
<p>Marks a module as whitelisted for introspection.</p>
<p>Example to ensure that all the functions in my_lib are considered by DDS.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import my_lib
dds.whitelist_module(my_lib)</p>
</blockquote>
</blockquote>
</blockquote>
<p>alternative approach if you do not want to import the my_lib module:</p>
<blockquote>
<blockquote>
<blockquote>
<p>dds.whitelist_module("my_lib")</p>
</blockquote>
</blockquote>
</blockquote>
<details class="quote">
          <summary>Source code in <code>dds/__init__.py</code></summary>
          <div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">whitelist_module</span><span class="p">(</span><span class="n">module</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ModuleType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Marks a module as whitelisted for introspection.</span>

<span class="sd">    Example to ensure that all the functions in my_lib are considered by DDS.</span>

<span class="sd">    &gt;&gt;&gt; import my_lib</span>
<span class="sd">    &gt;&gt;&gt; dds.whitelist_module(my_lib)</span>

<span class="sd">    alternative approach if you do not want to import the my_lib module:</span>

<span class="sd">    &gt;&gt;&gt; dds.whitelist_module("my_lib")</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">_whitelist_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../test_sklearn/" class="btn btn-neutral float-right" title="Tutorial - scikit-learn">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../test_sklearn/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
